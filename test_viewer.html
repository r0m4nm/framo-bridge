<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Framo GLB Viewer - MVP Test</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: Arial, sans-serif;
            overflow: hidden;
            background: linear-gradient(to bottom, #1a1a2e, #0f0f1e);
        }
        
        #status {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px 20px;
            border-radius: 8px;
            font-size: 14px;
            z-index: 100;
            min-width: 250px;
        }
        
        #status h3 {
            margin-bottom: 10px;
            color: #4CAF50;
        }
        
        #status .info {
            margin: 5px 0;
            opacity: 0.9;
        }
        
        #status .connected {
            color: #4CAF50;
        }
        
        #status .disconnected {
            color: #f44336;
        }
        
        #canvas-container {
            width: 100vw;
            height: 100vh;
        }
        
        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            display: none;
        }
        
        .spinner {
            border: 3px solid rgba(255, 255, 255, 0.3);
            border-radius: 50%;
            border-top: 3px solid white;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div id="status">
        <h3>Framo GLB Viewer</h3>
        <div class="info">Server: <span id="server-status" class="disconnected">Checking...</span></div>
        <div class="info">Model: <span id="model-status">No model loaded</span></div>
        <div class="info">Size: <span id="model-size">-</span></div>
        <div class="info">Triangles: <span id="poly-count">-</span></div>
    </div>
    
    <div id="loading">
        <div class="spinner"></div>
        Loading model...
    </div>
    
    <div id="canvas-container"></div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
    
    <script type="module">
        import * as THREE from 'three';
        import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
        import { DRACOLoader } from 'three/addons/loaders/DRACOLoader.js';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { RGBELoader } from 'three/addons/loaders/RGBELoader.js';
        
        // Three.js setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        
        // Camera
        const camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.set(5, 5, 5);
        
        // Renderer
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.toneMapping = THREE.ACESFilmicToneMapping;
        renderer.toneMappingExposure = 1;
        renderer.outputColorSpace = THREE.SRGBColorSpace;
        container.appendChild(renderer.domElement);
        
        // Controls
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        
        // Load HDRI Environment
        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        pmremGenerator.compileEquirectangularShader();
        
        const rgbeLoader = new RGBELoader();
        rgbeLoader.load(
            'https://dl.polyhaven.org/file/ph-assets/HDRIs/hdr/1k/studio_small_08_1k.hdr',
            (texture) => {
                const envMap = pmremGenerator.fromEquirectangular(texture).texture;
                scene.environment = envMap;
                scene.background = envMap;
                texture.dispose();
                pmremGenerator.dispose();
            },
            undefined,
            (error) => {
                console.log('HDRI loading failed, using fallback lighting');
                // Fallback lighting if HDRI fails to load
                scene.background = new THREE.Color(0x1a1a2e);
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                scene.add(ambientLight);
            }
        );
        
        // Keep directional light for shadows
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
        directionalLight.position.set(5, 10, 5);
        directionalLight.castShadow = true;
        directionalLight.shadow.camera.far = 50;
        directionalLight.shadow.camera.left = -10;
        directionalLight.shadow.camera.right = 10;
        directionalLight.shadow.camera.top = 10;
        directionalLight.shadow.camera.bottom = -10;
        scene.add(directionalLight);
        
        // Grid helper
        const gridHelper = new THREE.GridHelper(10, 10, 0x444444, 0x222222);
        scene.add(gridHelper);
        
        // Setup DRACO Loader
        const dracoLoader = new DRACOLoader();
        dracoLoader.setDecoderPath('https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/libs/draco/');
        dracoLoader.setDecoderConfig({ type: 'js' });
        
        // Setup GLTF Loader with DRACO support
        const loader = new GLTFLoader();
        loader.setDRACOLoader(dracoLoader);
        
        // Current model
        let currentModel = null;
        let lastModelHash = null;
        
        // Server status
        async function checkServerStatus() {
            try {
                const response = await fetch('http://localhost:8080/ping');
                if (response.ok) {
                    document.getElementById('server-status').textContent = 'Connected';
                    document.getElementById('server-status').className = 'connected';
                    return true;
                }
            } catch (e) {
                document.getElementById('server-status').textContent = 'Disconnected';
                document.getElementById('server-status').className = 'disconnected';
            }
            return false;
        }
        
        // Load model from server
        async function loadLatestModel() {
            try {
                const response = await fetch('http://localhost:8080/latest-model');
                if (response.ok) {
                    const blob = await response.blob();
                    
                    // Simple hash to detect changes
                    const arrayBuffer = await blob.arrayBuffer();
                    const hash = arrayBuffer.byteLength;
                    
                    if (hash === lastModelHash) {
                        return; // Same model, skip
                    }
                    
                    lastModelHash = hash;
                    
                    // Show loading
                    document.getElementById('loading').style.display = 'block';
                    
                    const url = URL.createObjectURL(new Blob([arrayBuffer]));
                    
                    loader.load(
                        url,
                        (gltf) => {
                            // Remove old model
                            if (currentModel) {
                                scene.remove(currentModel);
                            }
                            
                            // Add new model
                            currentModel = gltf.scene;
                            scene.add(currentModel);
                            
                            // Center and scale model
                            const box = new THREE.Box3().setFromObject(currentModel);
                            const center = box.getCenter(new THREE.Vector3());
                            const size = box.getSize(new THREE.Vector3());
                            
                            // Move model to origin
                            currentModel.position.sub(center);
                            
                            // Scale to fit
                            const maxDim = Math.max(size.x, size.y, size.z);
                            const scale = 5 / maxDim;
                            currentModel.scale.multiplyScalar(scale);
                            
                            // Enable shadows
                            currentModel.traverse((child) => {
                                if (child.isMesh) {
                                    child.castShadow = true;
                                    child.receiveShadow = true;
                                }
                            });
                            
                            // Update camera
                            controls.reset();
                            camera.position.set(5, 5, 5);
                            controls.update();
                            
                            // Update status
                            document.getElementById('model-status').textContent = 'Model loaded';
                            document.getElementById('model-size').textContent = (blob.size / (1024 * 1024)).toFixed(2) + ' MB';
                            
                            // Count polygons
                            let polyCount = 0;
                            currentModel.traverse((child) => {
                                if (child.isMesh && child.geometry) {
                                    if (child.geometry.index) {
                                        polyCount += child.geometry.index.count / 3;
                                    } else {
                                        polyCount += child.geometry.attributes.position.count / 3;
                                    }
                                }
                            });
                            document.getElementById('poly-count').textContent = Math.floor(polyCount).toLocaleString();
                            
                            // Hide loading
                            document.getElementById('loading').style.display = 'none';
                            
                            // Clean up URL
                            URL.revokeObjectURL(url);
                        },
                        (progress) => {
                            // Progress callback
                        },
                        (error) => {
                            console.error('Error loading model:', error);
                            document.getElementById('loading').style.display = 'none';
                            document.getElementById('model-status').textContent = 'Error loading model';
                        }
                    );
                }
            } catch (e) {
                // No model available yet
            }
        }
        
        // Poll for updates
        setInterval(async () => {
            const serverUp = await checkServerStatus();
            if (serverUp) {
                await loadLatestModel();
            }
        }, 2000);
        
        // Initial check
        checkServerStatus();
        
        // Animation loop
        function animate() {
            requestAnimationFrame(animate);
            
            controls.update();
            
            renderer.render(scene, camera);
        }
        animate();
        
        // Handle window resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        
        // Instructions
        console.log('%cFramo GLB Viewer Ready!', 'color: #4CAF50; font-size: 16px; font-weight: bold;');
        console.log('%cWaiting for models from Blender...', 'color: #2196F3; font-size: 14px;');
        console.log('%cMake sure the Framo Export addon is enabled in Blender', 'color: #FF9800; font-size: 12px;');
    </script>
</body>
</html>